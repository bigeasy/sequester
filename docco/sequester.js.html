<!DOCTYPE html>

<html>
<head>
  <title>sequester.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>

      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">


                <a class="source" href="sequester.js.html">
                  sequester.js
                </a>


                <a class="source" href="readme.t.js.html">
                  readme.t.js
                </a>

            </div>
          </div>
        </li>
      </ul>

    <ul class="sections">

          <li id="title">
              <div class="annotation">
                  <h1>sequester.js</h1>
              </div>
          </li>



        <li id="section-1">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>Internally, Sequester keeps a queue of lock requests in an array. The lock
requests always alternate shared, exclusive, shared, etc. The last element of
the lock queue array is always a shared lock. There is always at least one
element in the lock queue array. Therefore, when there is only one element in
the lock queue array it is a shared lock.</p>

            </div>

        </li>


        <li id="section-2">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>The shared lock has a counter. A shared lock can be held by many. An
exclusive lock can only be held by one. An exclusive lock does not have a
counter.</p>

            </div>

        </li>


        <li id="section-3">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>The lock in the first element of the lock queue array is the active lock. Any
locks after the first element of the lock queue array are waiting locks.</p>

            </div>

        </li>


        <li id="section-4">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>When you request an exclusive lock an exclusive lock is pushed onto the lock
queue array followed by a shared lock so that the last element of the array
is always a shared lock. You receive a promise that will resolve when the
exclusive lock reaches the front of the array.</p>

            </div>

        </li>


        <li id="section-5">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>When you request a shared lock that request is always added by incrementing
the shared lock counter of the last element of the array. (The last element
of lock queue array is always a shared lock.) You will receive a promise that
will resolve when the shared lock reaches the front of the array.</p>

            </div>

        </li>


        <li id="section-6">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>This is how we implement a reader-preferenced read/write lock and ensure that
the lock makes progress. Exclusive locks are always pushed onto the array so
no exclusive lock will be added before it. Shared locks will always increment
the counter of the shared lock at the end of the array so the counters of all
the shared locks in front of an exclusive lock can only go down.</p>

            </div>

        </li>


        <li id="section-7">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>When a shared lockâ€™s count reaches zero, if there are locks after it in the
queue, the lock is shifted from the front of the lock queue array. The next
lock becomes the active lock. The next lock will be an exclusive lock
followed by the new shared tail.</p>

            </div>

        </li>


        <li id="section-8">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>If the count reaches zero and there are no locks waiting, we just leave that
shared lock in the lock queue array as its single element. When there is no
contention &mdash; no waiting locks &mdash; Sequester is just a counter going
up and down. Practically a no-op.</p>

            </div>

        </li>


        <li id="section-9">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-built_in">module</span>.exports = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sequester</span> </span>{
    <span class="hljs-title">constructor</span> (<span class="hljs-params"></span>) {
        <span class="hljs-built_in">this</span>._queue = [{ <span class="hljs-attr">exclusive</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">promise</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">resolve</span>: <span class="hljs-literal">null</span> }]
    }

    get mutexes () {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._queue.map(<span class="hljs-function"><span class="hljs-params">mutex</span> =&gt;</span> mutex.count)
    }

    get state () {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._queue[<span class="hljs-number">0</span>].exclusive ? <span class="hljs-string">&#x27;exclusive&#x27;</span> : <span class="hljs-string">&#x27;shared&#x27;</span>
    }

    increment (count) {
        <span class="hljs-built_in">this</span>._queue[<span class="hljs-number">0</span>].count += count
    }

    share () {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._queue.length == <span class="hljs-number">1</span>) {
            <span class="hljs-built_in">this</span>._queue[<span class="hljs-number">0</span>].count++
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
        }
        <span class="hljs-keyword">const</span> shared = <span class="hljs-built_in">this</span>._queue[<span class="hljs-built_in">this</span>._queue.length - <span class="hljs-number">1</span>]
        shared.count++
        <span class="hljs-keyword">return</span> shared.promise
    }

    exclude () {
        <span class="hljs-keyword">const</span> exclusive = {
            <span class="hljs-attr">exclusive</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">count</span>: <span class="hljs-number">1</span>,
            <span class="hljs-attr">promise</span>: <span class="hljs-built_in">this</span>._queue.length == <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">this</span>._queue[<span class="hljs-number">0</span>].count == <span class="hljs-number">0</span>
                ? <span class="hljs-literal">null</span>
                : <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">this</span>._queue[<span class="hljs-built_in">this</span>._queue.length - <span class="hljs-number">1</span>].resolve = resolve),
            <span class="hljs-attr">resolve</span>: <span class="hljs-literal">null</span>
        }
        <span class="hljs-keyword">const</span> shared = {
            <span class="hljs-attr">exclusive</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">upgradable</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">promise</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> exclusive.resolve = resolve),
            <span class="hljs-attr">resolve</span>: <span class="hljs-literal">null</span>
        }
        <span class="hljs-built_in">this</span>._queue.push(exclusive, shared)
        <span class="hljs-keyword">if</span> (exclusive.promise == <span class="hljs-literal">null</span>) {
            <span class="hljs-built_in">this</span>._queue.shift()
        }
        <span class="hljs-keyword">return</span> exclusive.promise
    }

    downgrade () {
        <span class="hljs-built_in">this</span>._queue[<span class="hljs-number">1</span>].count++
        <span class="hljs-built_in">this</span>.unlock()
    }

    unlock () {
        <span class="hljs-built_in">this</span>._queue[<span class="hljs-number">0</span>].count--
        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>._queue.length != <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">this</span>._queue[<span class="hljs-number">0</span>].count == <span class="hljs-number">0</span>) {
            <span class="hljs-built_in">this</span>._queue.shift().resolve.call()
        }
    }
}</pre></div></div>

        </li>

    </ul>
  </div>
</body>
</html>
