<!DOCTYPE html>

<html>
<head>
  <title>readme.t.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>

      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">


                <a class="source" href="sequester.js.html">
                  sequester.js
                </a>


                <a class="source" href="readme.t.js.html">
                  readme.t.js
                </a>

            </div>
          </div>
        </li>
      </ul>

    <ul class="sections">

          <li id="title">
              <div class="annotation">
                  <h1>readme.t.js</h1>
              </div>
          </li>



        <li id="section-1">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;proof&#x27;</span>)(<span class="hljs-number">29</span>, <span class="hljs-keyword">async</span> okay =&gt; {
    <span class="hljs-keyword">const</span> Sequester = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;..&#x27;</span>)</pre></div></div>

        </li>


        <li id="section-2">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">const</span> sequester = <span class="hljs-keyword">new</span> Sequester</pre></div></div>

        </li>


        <li id="section-3">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-4">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Because this is a unit test we need to assert something. We’re going to
check the state of Sequester’s mutex queue.</p>
<p>The <code>mutexes</code> property is really for sake of this unit test. It displays
the count of locks for each mutex in the mutex queue array.</p>

            </div>

        </li>


        <li id="section-5">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    okay(sequester.mutexes, [ <span class="hljs-number">0</span> ], <span class="hljs-string">&#x27;display of empty mutex queue&#x27;</span>)</pre></div></div>

        </li>


        <li id="section-6">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-7">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>How to we read the these mutex dumps?</p>
<p>Again, each element in the dump is the count of locks for each mutex in
the mutex queue array. Let’s describe the mutex queue array.</p>
<p>The first element is the active mutex. Any additional elements are
waiting mutexes. Mutexes alternate shared, exclusive, share, exclusive,
etc. The first mutex in the mutex queue array can be either shared or
exclusive mutex. The last mutex is always a shared mutex. Because the
last mutex is always a shared mutex and mutexes alternate from one type
to the other we know that an odd number of mutexes means the active mutex
is shared and an even number of mutexes means the active mutex is
exclusive.</p>
<p>There is always one mutex in the mutex queue array. When there is only
one mutex in the mutex queue array, it is a shared mutex.</p>

            </div>

        </li>


        <li id="section-8">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    okay(sequester.mutexes, [ <span class="hljs-number">0</span> ], <span class="hljs-string">&#x27;single shared mutex with no locks&#x27;</span>)</pre></div></div>

        </li>


        <li id="section-9">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-10">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Enough of that. For more details on how the queue works you can read the
documentation in <code>sequester.js</code>.</p>

            </div>

        </li>


        <li id="section-11">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">const</span> log = []
    <span class="hljs-keyword">const</span> count = { <span class="hljs-attr">shared</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">exclusive</span>: <span class="hljs-number">0</span> }</pre></div></div>

        </li>


        <li id="section-12">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-13">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>For our tutorial we are going to have a function that we must guard with
a shared/exclusive lock. We’re going to pretend that this function does
some reading most of the time and some writing on occasion.</p>

            </div>

        </li>


        <li id="section-14">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">guarded</span> (<span class="hljs-params">message</span>) </span>{
        log.push(<span class="hljs-string">`<span class="hljs-subst">${message}</span> <span class="hljs-subst">${++count[message]}</span>`</span>)
    }</pre></div></div>

        </li>


        <li id="section-15">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-16">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Sequester prioritizes shared lock performance. To acquire a shared lock
you call <code>sequester.share()</code> if it returns <code>null</code> the lock was
uncontested so a shared lock is acquired immediately and you can proceed
to perform shared actions on your guarded code.</p>
<p>If the lock is contested &mdash; if there are  exclusive locks active or
waiting &mdash; <code>sequester.share()</code> returns a <code>Promise</code>. When the promise
is resolved the shared lock has been acquired and you can proceed to
perform actions on your guarded code.</p>
<p>By returning a <code>Promise</code> only if the lock is contested you can skip the
time you’d spend awaiting an <code>async</code> call in the <code>PromiseJob</code> queue.
Sequester simply increments a counter.</p>

            </div>

        </li>


        <li id="section-17">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {</pre></div></div>

        </li>


        <li id="section-18">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p><em>Request a shared lock, maybe wait to obtain it.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">const</span> promise = sequester.share()
        <span class="hljs-keyword">if</span> (promise != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">await</span> promise
        }</pre></div></div>

        </li>


        <li id="section-19">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p><em>Our single active shared mutex now has one lock.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>        okay(sequester.mutexes, [ <span class="hljs-number">1</span> ], <span class="hljs-string">&#x27;single shared lock&#x27;</span>)</pre></div></div>

        </li>


        <li id="section-20">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p><em>Do something contentious.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>        guarded(<span class="hljs-string">&#x27;shared&#x27;</span>)</pre></div></div>

        </li>


        <li id="section-21">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p><em>Release the shared lock.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>        sequester.unlock()</pre></div></div>

        </li>


        <li id="section-22">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p><em>Check our log.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>        okay(log.splice(<span class="hljs-number">0</span>), [ <span class="hljs-string">&#x27;shared 1&#x27;</span> ], <span class="hljs-string">&#x27;one shared action&#x27;</span>)
    }</pre></div></div>

        </li>


        <li id="section-23">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-24">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>When you are done with your guarded work you release the lock by calling
<code>sequester.unlock()</code>. You must release the lock, put it in a <code>finally</code>
block if you code might throw an exception you plan to recover from.</p>
<p>To obtain an exclusive lock you call <code>sequester.exclude()</code>. If it returns
returns <code>null</code> the lock was uncontested so a shared lock is acquired
immediately and you can proceed to perform shared actions on your guarded
code.</p>
<p>If the lock is contested &mdash; if there are shared or exclusive locks
active or waiting &mdash; <code>sequester.share()</code> returns a <code>Promise</code>. When
the promise is resolved the shared lock has been acquired and you can
proceed to perform actions on your guarded code.</p>

            </div>

        </li>


        <li id="section-25">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {</pre></div></div>

        </li>


        <li id="section-26">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p><em>Request an exclusive lock, maybe wait to obtain.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">const</span> promise = sequester.exclude()
        <span class="hljs-keyword">if</span> (promise != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">await</span> promise
        }</pre></div></div>

        </li>


        <li id="section-27">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p><em>Our active exclusive mutex now has one lock.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>        okay(sequester.mutexes, [ <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ], <span class="hljs-string">&#x27;single exclusive lock, shared mutex with no locks waiting&#x27;</span>)</pre></div></div>

        </li>


        <li id="section-28">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p><em>Do something contentious.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>        guarded(<span class="hljs-string">&#x27;exclusive&#x27;</span>)</pre></div></div>

        </li>


        <li id="section-29">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p><em>Release the exclusive lock.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>        sequester.unlock()</pre></div></div>

        </li>


        <li id="section-30">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p><em>Our mutex queue is idle again.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>        okay(sequester.mutexes, [ <span class="hljs-number">0</span> ], <span class="hljs-string">&#x27;single shared mutex with no locks&#x27;</span>)</pre></div></div>

        </li>


        <li id="section-31">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p><em>Check our log.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>        okay(log.splice(<span class="hljs-number">0</span>), [ <span class="hljs-string">&#x27;exclusive 1&#x27;</span> ], <span class="hljs-string">&#x27;one exclusive action&#x27;</span>)
    }</pre></div></div>

        </li>


        <li id="section-32">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-33">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Note that you do not have to perform the test for the promise if you
don’t want to. If you call <code>await</code> on a non-promise it will get wrapped
in a <code>Promise</code> and enter the <code>PromiseJob</code> queue. Therefore, you can call
<code>sequester</code></p>

            </div>

        </li>


        <li id="section-34">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">await</span> sequester.exclude()
        okay(sequester.mutexes, [ <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ], <span class="hljs-string">&#x27;single exclusive lock, shared mutex with no locks waiting&#x27;</span>)
        guarded(<span class="hljs-string">&#x27;exclusive&#x27;</span>)
        sequester.unlock()
        okay(sequester.mutexes, [ <span class="hljs-number">0</span> ], <span class="hljs-string">&#x27;single shared mutex with no locks&#x27;</span>)
        okay(log.splice(<span class="hljs-number">0</span>), [ <span class="hljs-string">&#x27;exclusive 2&#x27;</span> ], <span class="hljs-string">&#x27;one exclusive action&#x27;</span>)
    }</pre></div></div>

        </li>


        <li id="section-35">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-36">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>I use a coverage tool in my unit tests and strive for 100% coverage. This
await-only-if-necessary branch can be hard to cover since concurrent code
is already difficult to cover. If I’m performing an exclusive lock in
order to do file system operations, the file system operations are going
to be the bottleneck, not a single pass through the <code>PromiseJobs</code> queue,
so I in this case I’m okay with skipping this optimization.</p>
<p>Shared locks are usually guarding synchronous actions &mdash; reading
objects that are already in memory &mdash; the optimization is sure to
provide some benefit.</p>

            </div>

        </li>


        <li id="section-37">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>The <code>sequester.unlock()</code> function unlocks both shared and exclusive
locks. One would imagine that this would invite trouble, but it’s pretty
easy to manage. You <strong>must</strong> wait for your lock to be obtained before
proceeding. You <strong>must</strong> pair every lock you obtain with a call to
<code>unlock()</code>. If you do this you shouldn’t lose count of your locks.</p>

            </div>

        </li>


        <li id="section-38">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">const</span> locks = []

        locks.push(sequester.share())
        locks.push(sequester.share())

        okay(sequester.mutexes, [ <span class="hljs-number">2</span> ], <span class="hljs-string">&#x27;single shared mutex with two locks&#x27;</span>)

        <span class="hljs-keyword">await</span> locks.shift()
        guarded(<span class="hljs-string">&#x27;shared&#x27;</span>)
        sequester.unlock()

        okay(sequester.mutexes, [ <span class="hljs-number">1</span> ], <span class="hljs-string">&#x27;shared mutex with one lock&#x27;</span>)

        <span class="hljs-keyword">await</span> locks.shift()
        guarded(<span class="hljs-string">&#x27;shared&#x27;</span>)
        sequester.unlock()

        okay(sequester.mutexes, [ <span class="hljs-number">0</span> ], <span class="hljs-string">&#x27;single shared mutex with no locks&#x27;</span>)

        okay(log.splice(<span class="hljs-number">0</span>), [ <span class="hljs-string">&#x27;shared 2&#x27;</span>, <span class="hljs-string">&#x27;shared 3&#x27;</span> ], <span class="hljs-string">&#x27;one exclusive action&#x27;</span>)
    }</pre></div></div>

        </li>


        <li id="section-39">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-40">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>We use that <code>locks</code> array in our example to ensure that we await each
lock separately and release it before awaiting the next lock. If we await
two locks in a row we can deadlock.</p>

            </div>

        </li>


        <li id="section-41">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <pre><code><span class="hljs-comment">// Don&#x27;t do it!</span>
<span class="hljs-keyword">await</span> sequester.share()
<span class="hljs-keyword">await</span> sequester.share()
<span class="hljs-comment">// You may never reach this point.</span>
sequester.unlock()
sequester.unlock()</code></pre>

            </div>

        </li>


        <li id="section-42">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>There is no deadlock detection. Just follow the rules. For a given path
of execution , do not await a new lock until you’ve unlocked the last
lock.</p>

            </div>

        </li>


        <li id="section-43">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>What is a path of execution? You can think of that as distinct
<code>async</code>/<code>await</code> call stack rooted from an <code>async</code> function call.</p>

            </div>

        </li>


        <li id="section-44">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reader</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">await</span> sequester.share()
            guarded(<span class="hljs-string">&#x27;shared&#x27;</span>)
            sequester.unlock()
        }

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writer</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">await</span> sequester.exclude()
            guarded(<span class="hljs-string">&#x27;exclusive&#x27;</span>)
            sequester.unlock()
        }

        <span class="hljs-keyword">const</span> promises = [ reader(), reader(), writer() ]

        okay(sequester.mutexes, [ <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ], <span class="hljs-string">&#x27;two shared, one exclusive, empty shared tail&#x27;</span>)

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> promise <span class="hljs-keyword">of</span> promises) {
            <span class="hljs-keyword">await</span> promise
        }

        okay(log.splice(<span class="hljs-number">0</span>), [ <span class="hljs-string">&#x27;shared 4&#x27;</span>, <span class="hljs-string">&#x27;shared 5&#x27;</span>, <span class="hljs-string">&#x27;exclusive 3&#x27;</span> ], <span class="hljs-string">&#x27;two shared, one exclusive action&#x27;</span>)
    }</pre></div></div>

        </li>


        <li id="section-45">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-46">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>In the above example make three function calls and wait for them to
return. We can see the locks build up in the mutex queue. The two calls
to <code>reader</code> will have to unlock <code>sequester</code> before the writer call can
obtain its exclusive lock.</p>

            </div>

        </li>


        <li id="section-47">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Each call to <code>reader</code> or <code>writer</code> made a single call to obtain a lock and
a single call to unlock. This is how you ensure that you do not have
deadlock. Pair a single call to lock with a single call to unlock within
an <code>async</code>/<code>await</code> call stack. The parallel paths of execution will be
able to co-ordinate access to guarded blocks of code.</p>

            </div>

        </li>


        <li id="section-48">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>In the above we used <code>await</code> directly on our calls to <code>share()</code> and
<code>exclude()</code>. What happens when we await-only-if-necessary?</p>

            </div>

        </li>


        <li id="section-49">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reader</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">const</span> promise = sequester.share()
            <span class="hljs-keyword">if</span> (promise != <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">await</span> promise
            }
            guarded(<span class="hljs-string">&#x27;shared&#x27;</span>)
            sequester.unlock()
        }

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writer</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">const</span> promise = sequester.exclude()
            <span class="hljs-keyword">if</span> (promise != <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">await</span> promise
            }
            guarded(<span class="hljs-string">&#x27;exclusive&#x27;</span>)
            sequester.unlock()
        }

        <span class="hljs-keyword">const</span> promises = [ reader(), reader(), writer() ]

        okay(sequester.mutexes, [ <span class="hljs-number">0</span> ], <span class="hljs-string">&#x27;single empty shared mutex&#x27;</span>)

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> promise <span class="hljs-keyword">of</span> promises) {
            <span class="hljs-keyword">await</span> promise
        }

        okay(log.splice(<span class="hljs-number">0</span>), [ <span class="hljs-string">&#x27;shared 6&#x27;</span>, <span class="hljs-string">&#x27;shared 7&#x27;</span>, <span class="hljs-string">&#x27;exclusive 4&#x27;</span> ], <span class="hljs-string">&#x27;two shared, one exclusive action&#x27;</span>)
    }</pre></div></div>

        </li>


        <li id="section-50">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-51">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>Would you look at that? Both the readers and the writer where able to
obtain thier locks immediately so they didn’t have to <code>await</code> the lock.
It was unnecessary. They where able to get straight to work without
having to go through the microtask queue.</p>

            </div>

        </li>


        <li id="section-52">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>However, we want to show how locks queue up in the mutex queue, so our
next few examples are going to use the <code>await</code> directly versions of the
<code>reader</code> and <code>writer</code>.</p>

            </div>

        </li>


        <li id="section-53">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reader</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">await</span> sequester.share()
        guarded(<span class="hljs-string">&#x27;shared&#x27;</span>)
        sequester.unlock()
    }

    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writer</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">await</span> sequester.exclude()
        guarded(<span class="hljs-string">&#x27;exclusive&#x27;</span>)
        sequester.unlock()
    }</pre></div></div>

        </li>


        <li id="section-54">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-55">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>Here we show how readers wait for writers.</p>

            </div>

        </li>


        <li id="section-56">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">const</span> promises = [ writer(), reader(), reader() ]

        okay(sequester.mutexes, [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ], <span class="hljs-string">&#x27;single empty shared mutex&#x27;</span>)

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> promise <span class="hljs-keyword">of</span> promises) {
            <span class="hljs-keyword">await</span> promise
        }

        okay(log.splice(<span class="hljs-number">0</span>), [ <span class="hljs-string">&#x27;exclusive 5&#x27;</span>, <span class="hljs-string">&#x27;shared 8&#x27;</span>, <span class="hljs-string">&#x27;shared 9&#x27;</span> ], <span class="hljs-string">&#x27;two shared, one exclusive action&#x27;</span>)
    }</pre></div></div>

        </li>


        <li id="section-57">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-58">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>This shows something about how we prevent starvation.</p>

            </div>

        </li>


        <li id="section-59">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">const</span> promises = [ writer(), writer(), reader() ]

        okay(sequester.mutexes, [ <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span> ], <span class="hljs-string">&#x27;exclusive, empty shared, exclusive, shared&#x27;</span>)

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> promise <span class="hljs-keyword">of</span> promises) {
            <span class="hljs-keyword">await</span> promise
        }

        okay(log.splice(<span class="hljs-number">0</span>), [ <span class="hljs-string">&#x27;exclusive 6&#x27;</span>, <span class="hljs-string">&#x27;exclusive 7&#x27;</span>, <span class="hljs-string">&#x27;shared 10&#x27;</span> ], <span class="hljs-string">&#x27;two shared, one exclusive action&#x27;</span>)
    }</pre></div></div>

        </li>


        <li id="section-60">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-61">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>Now that we’ve clearly established some rules, let’s move onto the part
where we break them.</p>

            </div>

        </li>


        <li id="section-62">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>Sequester also provides the concept of a countdown. There are times in
your application when you want to hold a lock, perform number of
operations in parallel, releasing the lock when all the parallel
operations finish.</p>
<p>For this we provide a countdown where once you hold a lock you can
increase the number of locks you hold using the <code>increment()</code> method.</p>
<p>The old rule that says you must call <code>unlock()</code> for every <code>shared()</code> or
<code>exclusive()</code> call is modified to say that you must call <code>unlock()</code> for
every <code>shared()</code> or <code>exclusive()</code> call plus the number you pass into a
call to <code>increment()</code> if you call <code>increment()</code>.</p>

            </div>

        </li>


        <li id="section-63">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parallel</span> (<span class="hljs-params"></span>) </span>{
            sequester.unlock()
        }

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">counted</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">await</span> sequester.share()
            sequester.increment(<span class="hljs-number">2</span>)
            okay(sequester.mutexes, [ <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ], <span class="hljs-string">&#x27;countdown shared, exclusive, shared tail&#x27;</span>)
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> promise <span class="hljs-keyword">of</span> [ parallel(), parallel(), parallel() ]) {
                <span class="hljs-keyword">await</span> promise
            }
        }

        <span class="hljs-keyword">const</span> promises = [ writer(), counted(), writer() ]

        okay(sequester.mutexes, [ <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ], <span class="hljs-string">&#x27;exclusive, shared, exclusive shared tail&#x27;</span>)

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> promise <span class="hljs-keyword">of</span> promises) {
            <span class="hljs-keyword">await</span> promise
        }
    }</pre></div></div>

        </li>


        <li id="section-64">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-65">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p><code>increment()</code> also works with exclusive locks.</p>

            </div>

        </li>


        <li id="section-66">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parallel</span> (<span class="hljs-params"></span>) </span>{
            sequester.unlock()
        }

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">counted</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">await</span> sequester.exclude()
            sequester.increment(<span class="hljs-number">2</span>)
            okay(sequester.mutexes, [ <span class="hljs-number">3</span>, <span class="hljs-number">1</span> ], <span class="hljs-string">&#x27;countdown exclusive, single shared in tail&#x27;</span>)
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> promise <span class="hljs-keyword">of</span> [ parallel(), parallel(), parallel() ]) {
                <span class="hljs-keyword">await</span> promise
            }
        }

        <span class="hljs-keyword">const</span> promises = [ reader(), counted(), reader() ]

        okay(sequester.mutexes, [ <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span> ], <span class="hljs-string">&#x27;exclusive, shared, exclusive shared tail&#x27;</span>)

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> promise <span class="hljs-keyword">of</span> promises) {
            <span class="hljs-keyword">await</span> promise
        }
    }</pre></div></div>

        </li>


        <li id="section-67">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>It kind of makes an exclusive block seem less exclusive if you can hold
multiple locks on it, but keep in mind that the <code>counted()</code> method above
is following the rule that the lock is held, incremented and released
within the same <code>async</code>/<code>await</code> call stack. The call stack fans out after
the lock is acquired.</p>
<p><code>downgrade()</code> is a synchronous method will downgrade an exclusive lock to
a shared lock that is held immediately after downgrade returns.</p>
<p>If the work you plan on doing has a write task followed by read tasks,
you can improve through put by downgrading then the writes are complete
still holding a lock. This will prevent other strands from changing the
guarded data, but allowing other readers to commence with reading the
guarded data.</p>
<p>I’ve not had a use for <code>downgrade()</code>, but it is easy enough to implement.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">downgraded</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">await</span> sequester.exclude()
            okay(sequester.mutexes, [ <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ], <span class="hljs-string">&#x27;exclusive lock held&#x27;</span>)
            sequester.downgrade()
            okay(sequester.mutexes, [ <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ], <span class="hljs-string">&#x27;exclusive lock downgraded to shared&#x27;</span>)
            sequester.unlock()
        }

        <span class="hljs-keyword">const</span> promises = [ downgraded(), writer() ]

        okay(sequester.mutexes, [ <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ], <span class="hljs-string">&#x27;exclusive, empty shared, exclusive, shared tail&#x27;</span>)

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> promise <span class="hljs-keyword">of</span> promises) {
            <span class="hljs-keyword">await</span> promise
        }
    }
})</pre></div></div>

        </li>

    </ul>
  </div>
</body>
</html>
